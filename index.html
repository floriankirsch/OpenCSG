<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
"http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Florian Kirsch">
  <meta name="KeyWords" content="OpenCSG, CSG, image-based, image-based CSG, rendering, SCS, Goldfeather, OpenGL">

  <title>OpenCSG - The CSG rendering library</title>
  <link rel="shortcut icon" href="http://www.opencsg.org/favicon.ico" type="image/ico">
</head>

<body style="font-family: verdana,arial,sans-serif">

<table cellpadding="10" cellspacing="0" border="0">
 <tbody>
  <tr><td><img src="img/logo.gif" alt="OpenCSG logo"></td>
   <td style="text-align: center;">
     <h1> OpenCSG </h1>
     <h3> The CSG rendering library </h3>

     <b>
     <a href="news.html">News</a> &nbsp;&nbsp;
     <a href="#introduction">Introduction</a> &nbsp;&nbsp;
     <a href="#benefits">Benefits</a> &nbsp;&nbsp;
     <a href="#prerequisites">Prerequisites</a> &nbsp;&nbsp;
     <a href="#usage">Usage</a> &nbsp;&nbsp;
     <a href="#download">Download</a> &nbsp;&nbsp;
     <a href="#applications">Applications</a> &nbsp;&nbsp;
     <a href="#background">Background</a> &nbsp;&nbsp;
     <a href="publications.html">Publications</a> &nbsp;&nbsp;
     <a href="#FAQ">FAQ</a> &nbsp;&nbsp;
     <a href="#license">License</a> &nbsp;&nbsp;
     </b>
   </td>
   <td><img src="img/ogl.gif" alt="OpenGL logo"></td>
  </tr>
 </tbody>
</table>

<hr>

<h3> <a href="news.html">Latest release: OpenCSG 1.3.1 (09.06.2010)</a></h3>

<hr>

<h3> <a name="introduction">Introduction</a> </h3>

<p>
OpenCSG is a library that does image-based CSG rendering using OpenGL. 
OpenCSG is written in C++ and supports most modern graphics hardware using
Microsoft Windows or the Linux operating system. 
<a href="http://www.opencsg.org/OpenCSG-1.3.1.tar.gz">OpenCSG-1.3.1</a> is the current version.
</p>

<p>
What is CSG, anyway? CSG is short for <b>Constructive Solid Geometry</b>
and denotes an approach to model complex 3D-shapes using simpler ones. I.e.,
two shapes can be combined by taking the union of them, by intersecting
them, or by subtracting one shape of the other. The
most basic shapes, which are not result of such a CSG operation,
are called <b> primitives</b>. Primitives must be <b>solid</b>, i.e.,
they must have a clearly defined interior and exterior. By construction,
a CSG shape is also solid then. 
</p>

<p>
Image-based CSG rendering (also z-buffer CSG rendering) is a term that
denotes algorithms for rendering CSG shapes without an explicit calculation
of the geometric boundary of a CSG shape. Such algorithms use
frame-buffer settings of the graphics hardware, e.g., the depth and stencil
buffer, to compose CSG shapes. <b>OpenCSG</b> implements a variety of 
those algorithms, namely the <b>Goldfeather</b> algorithm and the <b>SCS</b> 
algorithm, both of them in several variants.  
</p>

<center><a href="http://www.opencsg.org/img/grid.jpg"><img src="img/grid.gif" border="0" alt="CSG grid"></a></center>

<hr>

<h3> <a name="benefits">Benefits</a> </h3>

<p>
CSG is often used as fundamental modeling technique in CAD/CAM applications.
Here, image-based CSG rendering is the key to interactively manipulate CSG 
shapes. Since OpenCSG renders even complex CSG shapes fast, it can 
be advantageously used in such applications. 
</p>

<p>
Raytracers such as <a href="http://www.povray.org">PovRay</a> have 
used CSG for shape modeling since long ago. Interactive modeling
toolkits for such raytracers normally just ignore CSG commands, though. 
OpenCSG represents a valuable addition for such applications.
</p>

<p>
Overall, up to the present CSG rendering has been hardly used in interactive 
applications, since the necessary algorithms are complicated and error-prone. 
We hope that by providing a free library that is easy to use, fast, and 
versatile, CSG rendering can be made more mainstream than it currently 
is. 
</p>

<center><a href="http://www.opencsg.org/img/columns.jpg"><img src="img/columns.gif" border="0" alt="CSG columns"></a></center>

<hr>

<h3> <a name="prerequisites">Prerequisites</a> </h3>

<p>
The OpenCSG library requires graphics hardware that either supports 
the <b>PBuffer</b> or frame buffer objects in OpenGL. With PBuffers, 
it is advantegeous if the related Render-to-Texture facility is also 
supported. Actually, OpenCSG uses the 
<a href="http://sourceforge.net/project/showfiles.php?group_id=104004&amp;package_id=115053">
RenderTexture class</a> as PBuffer library.
</p>

<p>
PBuffers have been widely supported since a long time now. NVidia supports them
since the Riva TNT, and ATI at least since the Radeon series. Graphics
hardware from other hardware vendors, however, likely do not support 
PBuffers. Therefore, if you have obscure graphics hardware, you are
probably out of luck and you cannot run programs using OpenCSG. With
Linux, you have probably the option to use 
<a href="http://www.mesa3d.org/"></a> supporting OpenGL software
rendering and PBuffers at the same time.
</p>

<p>
Frame buffer objects are a more recent extension for OpenGL. They are
easier to develop for, and can nowadays (2010) be considered mature.
They are also part of OpenGL 3.0. Beginning with OpenCSG 1.2.0, they
are used by default by OpenCSG. In older versions, PBuffers were the
default.
</p>

<p>
For OpenGL-Extension checking, OpenCSG uses the OpenGL Extension Wrangler
Library <a href="http://glew.sourceforge.net">GLEW</a>.
</p>

<p>
OpenCSG is written in C++, uses namespaces and requires the STL. I do not expect major
compiler incompatibilities under Windows. Workspaces for with MSVC6, 
VC2003 .net and <a href="http://www.bloodshed.net/devcpp.html">Dev-C++ 5 beta</a> are provided. Under
Linux, you should use gcc version 3 or newer. gcc-2.95.x will not work, since this compiler
does not come with a std::map implementation, which is required internally. 
</p>

<p>
To run OpenCSG well, you should have graphics hardware with lots of fill
rate. NVidia graphics hardware since GeForce and ATI Radeon qualify. 
The <code>OpenCSG::OcclusionQuery</code> option obviously requires occlusion
queries, which are available since Radeon 9x00 (x>=5) and GeForce3
(beware that the GeForce4MX counts as GeForce2!).
</p>

<p>
OpenCSG has been sucessfully run on Intel and AMD hardware using 
Radeon HD 4670,
GeForce 8x00, 
GeForceFX 6800,
GeForceFX 5600,
Radeon 9700,
GeForce3,
GeForce4MX,
and TNT2 graphcs hardware (on the latter, it crawls ...).
</p>

<p>
On a Radeon 9000, OpenCSG was once known to produce rendering errors
in all but the standard Goldfeather rendering path. It is unclear whether
this was possibly a driver issue. I have no experiences running OpenCSG
on graphics hardware other than from NVidia or ATI/AMD.
</p>

<center><a href="http://www.opencsg.org/img/conc.jpg"><img src="img/conc.gif" border="0" alt="CSG convace shape"></a></center>

<hr>

<h3> <a name="usage">Usage</a> </h3>

<p>
<a name="primitive"></a>
The interface of OpenCSG is very easy to use. There
is only a single abstract class called <code><b>OpenCSG::Primitive</b></code>.
<a name="interfaceoperation"></a>
A <code>Primitive</code> object has an attribute <code><b>Operation</b></code>
that denotes whether the primitive is intersected or subtracted. 
To use OpenCSG, create a derived concrete primitive class by 
implementing the <code>render()</code> method. 
</p>

<p>
<a name="rendershape"></a>
To actually do the CSG rendering, there is the function <code><b>OpenCSG::render()</b></code> 
that takes a <code>std::vector&lt;Primitive*&gt;</code> as argument. 
The render function evaluates the CSG expression given by the array of primitives
and initializes the z-buffer with the proper values for the CSG expression.
The color buffer remains unchanged, so afterwards, you must shade
the primitives in the array using a <code>GL_EQUAL</code> depth function.
</p>

<p>
Note that the render function does not evaluate a generic CSG tree that
also would contain unions of CSG shapes. It has been shown that a
generic CSG tree can be converted into an equivalent set of CSG expressions
that the render function can handle. OpenCSG does not contain the 
functionality for this conversion since, after all, it is a rendering
library. 
</p>

<p>
Here is the complete interface of OpenCSG:
</p>
<p>
<code>
namespace OpenCSG { <br>
<br>
&nbsp; enum <b><a href="#interfaceoperation">Operation</a></b> { <b>Intersection</b>, <b>Subtraction</b> }; <br>
<br>
&nbsp; <b><a href="#primitive">class Primitive</a></b> { <br>
&nbsp; public: <br>
&nbsp;&nbsp; <b><a href="#primitive">Primitive</a></b>(Operation, unsigned int convexity); <br>
&nbsp;&nbsp; virtual <b><a href="#primitive">~Primitive</a></b>(); <br>
<br>
&nbsp;&nbsp; void <b><a href="#interfaceoperation">setOperation</a></b>(Operation); <br>
&nbsp;&nbsp; Operation <b><a href="#interfaceoperation">getOperation</a></b>() const; <br>
<br>
&nbsp;&nbsp; void <b><a href="#interfaceconvexity">setConvexity</a></b>(unsigned int); <br>
&nbsp;&nbsp; unsigned int <b><a href="#interfaceconvexity">getConvexity</a></b>() const; <br>
<br>
&nbsp;&nbsp; void <b><a href="#interfacebounds">setBoundingBox</a></b>(float  minx, float  miny, float  minz, <br>
&nbsp;&nbsp;&nbsp;&nbsp; float  maxx, float  maxy, float  maxz); <br>
&nbsp;&nbsp; void <b><a href="#interfacebounds">getBoundingBox</a></b>(float&amp; minx, float&amp; miny, float&amp; minz, <br>
&nbsp;&nbsp;&nbsp;&nbsp; float&amp; maxx, float&amp; maxy, float&amp; maxz) const; <br>
<br>
&nbsp;&nbsp; <b><a href="#interfacerenderprimitive">virtual void render</a></b>() = 0; <br>
&nbsp; }; <br>
<br>
&nbsp; enum <b><a href="#options">OptionType</a></b> { <br>
&nbsp;&nbsp; <b><a href="#algorithm">AlgorithmSetting</a></b>, <br>
&nbsp;&nbsp; <b><a href="#depthalgorithm">DepthComplexitySetting</a></b>, <br>
&nbsp;&nbsp; <b><a href="#offscreentype">OffscreenSetting</a></b>, <br>
&nbsp;&nbsp; <b><a href="#depthboundsoptimization">DepthBoundsOptimization</a></b>, <br>
&nbsp; }; <br>
<br>
&nbsp; void <b><a href="#options">setOption</a></b>(OptionType option, int newSetting);<br>
&nbsp; int <b><a href="#options">getOption</a></b>(OptionType option); <br>
<br>
&nbsp; enum <b><a href="#algorithm">Algorithm</a></b> { <b>Automatic</b>, <b>Goldfeather</b>, <b>SCS</b> }; <br>
&nbsp; enum <b><a href="#depthalgorithm">DepthComplexityAlgorithm</a></b> { <b>NoDepthComplexitySampling</b>, <b>OcclusionQuery</b>, <b>DepthComplexitySampling</b> }; <br>
&nbsp; enum <b><a href="#offscreentype">OffscreenType</a></b> { <b>AutomaticOffscreenType</b>, <b>FrameBufferObject</b>, <b>PBuffer</b>, <b>FrameBufferObjectARB</b>, <b>FrameBufferObjectEXT</b> }; <br>
&nbsp; enum <b><a href="#optimization">Optimization</a></b> { <b>OptimizationDefault</b>, <b>OptimizationDefault</b>, <b>OptimizationOn</b>, <b>OptimizationOff</b> }; <br>
<br>
&nbsp; void <b><a href="#rendershape">render</a></b>(const std::vector&lt;Primitive*&gt;&amp; primitives); <br>
<br>
&nbsp; void <b><a href="#context">setContext</a></b>(int context); <br>
&nbsp; int <b><a href="#context">getContext</a></b>(); <br>
&nbsp; void <b><a href="#context">freeResources</a></b>(); <br>
} <br>
</code>
</p>

<p>
<a name="interfaceconvexity"></a>
The <b>convexity</b> of a primitive is the maximum number of front (or back) 
faces of the primitive at a single position. For example, the convexity
of a sphere is one and the convexity of a torus is two. Actually 
the convexity attribute is currently only used in the standard Goldfeather
algorithm. For this algorithm, a convexity too low may result in
rendering errors, a convexity too high will reduce rendering 
performance. The other Goldfeather variants render primitives of any
convexity correctly without analyzing the convexity attribute. 
The SCS algorithms, on the other hand, can only handle primitives 
that have a convexity of one, else they produce rendering errors. 
Hence, SCS algorithms do not check this attribute. 
</p>

<p>
<a name="interfacebounds"></a>
The <b>bounding box</b> of the primitive can be provided using normal device
coordinates, i.e., after transforming the primitive with modelview and 
projection transformation. It is not necessary to set the bounding
box, but it allows for various performance optimizations.
</p>

<p>
<a name="interfacerenderprimitive"></a>
The abstract <b><code>render</code> method</b> of the primitive is implemented in a
derived class. Your implementation must not alter the modelview or projection 
matrix (use <code>glPushMatrix</code> / <code>glPopMatrix</code> if in doubt).
Also you must not change the primary color in your implementation, since 
OpenCSG uses it internally (in all rendering algorithms). For best performance, 
you should only transmit vertex positions; no normals, texture coordinates, or 
whatever else.
</p>

<p>
The <b><code>render</code> function</b> performs, as said above, z-shading of
a CSG expression. The content of the stencil buffer is destroyed when
handling concave primitives or when using the <code>DepthComplexitySampling</code> 
strategy.
</p>

<p>
<a name="options"></a>
Using the functions <b><code>setOption() / getOption</code></b> you can control
and ask for certain settings used when rendering a CSG expression. These
functions were introduced with version 1.1.0 of OpenCSG. You can specify the 
<a href="#algorithm"> Algorithm</a>, the method of 
<a href="#depthalgorithm">depth
complexity usage</a> and the <a href="#offscreentype">type of offscreen
buffer</a>. There is an obsolete variant of the <b><code>render()</code></b>
function that takes these two options as additional arguments, temporarily
overriding the currently set options.
</p>

<p>
<a name="algorithm"></a>
The <b><code>Algorithm</code></b> parameter specifies the method used for CSG rendering.
Besides <code>Goldfeather</code> and <code>SCS</code>, you can also choose
<b><code>Automatic</code></b>: This setting chooses the Goldfeather algorithm if 
the primitive array contains concave primitives, else it chooses SCS. 
The automatic setting also sets the <code>DepthComplexityAlgorithm</code> 
(<code>NoDepthComplexitySampling</code> for arrays with few primitives, 
else <code>OcclusionQuery</code> or at the last resort <code>DepthComplexitySampling</code>).
</p>

<p>
Aforesaid means that it is, currently, not possible to do CSG
rendering of concave primitives and preserving the stencil buffer. I am
looking for ways to change this situation (The ARB_buffer_region extension 
appears to be a possible way for this). 
</p>

<p>
<a name="depthalgorithm"></a>
If the <code>Automatic</code> setting is not used,
the <b><code>DepthComplexityAlgorithm</code></b> parameter specifies the strategy 
for profiting from depth complexity.
</p>
<ul>
<li><code>NoDepthComplexitySampling</code>: Does not employ the depth complexity.
  This essentially makes the algorithm O(n²), but with low constant costs.</li>
<li><code>DepthComplexitySampling</code>: Calculates the depth complexity k using
  the stencil buffer. This makes the algorithm O(n*k), but with high constant costs. 
  In case of the Goldfeather algorithm, the literature denotes this as 
  layered Goldfeather algorithm.</li>
<li><code>OcclusionQuery</code>: Uses occlusion queries to profit implicitly from
  depth complexity without calculating it. This is especially useful for 
  the SCS algorithm where this strategy is applied at shape level, resulting in a 
  O(n*k') algorithm (where k' <= k), without significant constant overhead. 
  This strategy requires hardware occlusion queries, i.E., the OpenGL extension 
  <code>GL_ARB_occlusion_query</code> or <code>GL_NV_occlusion_query</code>.</li>
</ul>

<p>
<a name="offscreentype"></a>
The offscreen type specifies what kind of offscreen buffer OpenCSG uses for
internal CSG calculations. The default <code>AutomaticOffscreenType</code>
preferably uses, if the required OpenGL extensions are available,
<code>FrameBufferObjectARB</code>, then <code>PBuffer</code>, then <code>FrameBufferObjectEXT</code>.
The <code>FrameBufferObject</code> uses preferably <code>FrameBufferObjectARB</code>,
then <code>FrameBufferObjectEXT</code>. These priorities are subject to change
between different releases based on experiences with compatibility of OpenCSG
with different extensions and graphics hardware. The remaining settings <code>PBuffer</code>,
<code>FrameBufferObjectARB</code>, and <code>FrameBufferObjectEXT</code> directly map
to the usage of the corresponding OpenGL extension. Overall, using
frame buffer objects is potentially faster, because they do not impose
a separate rendering context for the offscreen buffer and hence require
no context switching. In typical scenarios, there is no difference though.
</p>

<p>
<a name="depthboundsoptimization"></a>
The depth bounds optimization improves the rendering performance by using
the OpenGL extension <code>GL_EXT_depth_bounds_test</code> to restrict
rendering to only the depth range indicated by the bounding box of a 
primitive. This optimization is, by default, turned off. If you enable
it, ensure that the z-ranges of the bounding boxes are large enough,
otherwise they will not be correctly rendered. The gains you will get
from this optimization is probably only small. 
</p>

<p>
<a name="context"></a>
OpenCSG creates, and reuses between different <code>render()</code> calls,
various OpenGL resources such as PBuffers or frame buffer objects. This
may be a problem in MDI applications with several OpenGL windows, of which
the OpenGL contexts are not shared. In this case, OpenGL resources allocated
in one OpenGL context cannot be reused with another context, so OpenCSG
would produce rendering errors. To solve this, the OpenCSG context
can be set to some unique integer identifier of the OpenGL window.
OpenCSG then creates/uses OpenGL resources in the <code>render()</code>
function per context. The function <code>freeResources()</code> frees
OpenGL resources for the currently active OpenCSG context. 
</p>

<center><a href="http://www.opencsg.org/img/grid.jpg"><img src="img/grid.gif" border="0" alt="CSG grid"></a></center>

<hr>

<h3> <a name="download">Download</a> </h3>

<p>
Download <a href="http://www.opencsg.org/OpenCSG-1.3.1.tar.gz">OpenCSG-1.3.1.tar.gz</a>. The archive contains all required helper
libraries, i.e., also RenderTexture and GLEW. It comes with 
makefiles for Linux and with project files for MSVC6, VS2003, and Dev-C++ 5.
</p>

<p>
The older versions <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-1.3.0.tar.gz">OpenCSG-1.3.0</a>, <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-1.2.0.tar.gz">OpenCSG-1.2.0</a>, <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-1.1.1.tar.gz">OpenCSG-1.1.1</a>, <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-1.1.0.tar.gz">OpenCSG-1.1.0</a>, <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-1.0.2.zip">OpenCSG-1.0.2</a>, <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-1.0.1.zip">OpenCSG-1.0.1</a>, <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-1.0.0.zip">OpenCSG-1.0.0</a>, <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-0.9.2.zip">OpenCSG-0.9.2</a>, <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-0.9.1.zip">OpenCSG-0.9.1</a> and <br>
&nbsp;&nbsp; <a href="http://www.opencsg.org/OpenCSG-0.9.zip">OpenCSG-0.9</a> <br>
are still available for download. 
</p>

<center><a href="http://www.opencsg.org/img/columns.jpg"><img src="img/columns.gif" border="0" alt="CSG columns"></a></center>

<hr>

<h3> <a name="applications">Applications</a> </h3>

<p>
Currently, I know of the following applications making use of OpenCSG:
</p>

<table cellpadding="10" cellspacing="0" border="0" style="text-align: left;">
<tbody>
<tr>
<td valign="top" style="text-align: center;"><a href="http://www.ayam3d.org"><img src="http://ayam.sourceforge.net/gp/ayam-splash-icon.jpg" alt="Ayam-Icon" /></a></td>
<td>
	<a href="http://www.ayam3d.org">Ayam</a> is a 3D modelling environment for the RenderMan interface, 
	running on Unix, Win32, and Mac OS X. Since version 1.8, Ayam provides the plugin aycsg for 
	<a href="http://ayam.sourceforge.net/aycsg-compass.gif">real-time CSG preview of complex CSG hierarchies</a>
	using OpenCSG as rendering library. 
</td>
</tr>
<tr>
<td valign="top" style="text-align: center;"><a href="http://neuron-ai.tuke.sk/~wagner/projects-csg.php"><img src="http://neuron-ai.tuke.sk/~wagner/smallimages/csg01.jpg" alt="Icon for KoraX CSG-Editor" /></a></td>
<td>
	<a href="http://neuron-ai.tuke.sk/~wagner/projects-csg.php">koraX's CSG Editor</a>. This editor for
	MS Windows allows to compose textured CSG shapes from a set of predefined primitives. The application
	contains a very good online help that depicts nicely what CSG is about, and that furthermore
	contains some tutorial how to create 1) a graphical widget and 2) a pipe.
</td>
</tr>
<tr>
<td valign="top" style="text-align: center;"><a href="http://openscad.org/"><img src="img/openscad.png" alt="Icon for OpenSCAD" /></a></td>
<td>
	<a href="http://openscad.org/">OpenSCAD</a> is a software
	for creating solid 3D CAD objects by means of a scripting language.
	It supports interactive preview of the CSG geometry as well as
	exporting the final geometry as 3D model. There are precompiled
	binaries for Linux, Windows, and MacOS X. 
</td>
</tr>
</tbody>
</table>

<center><a href="http://www.opencsg.org/img/conc.jpg"><img src="img/conc.gif" border="0" alt="CSG concave shape"></a></center>

<hr>

<h3> <a name="background">Background</a> </h3>

<p>
I have developed the algorithms for OpenCSG in my time as research assistent
at HPI at the University Potsdam. In this time the following publications 
about OpenCSG and about image-based CSG rendering have been written:
</p>

<table cellpadding="10" cellspacing="0" border="0" style="text-align: left;">
<tbody>
<tr>
<td valign="top" style="text-align: center;"><a href="http://www.opencsg.org/publications.html#wscg"><img src="img/drivetrain.gif" alt="WSCG04-Icon" /></a></td>
<td>
<p><b>F. Kirsch, J. Döllner: 
      <a href="http://www.opencsg.org/publications.html#wscg">Rendering Techniques for Hardware-Accelerated Image-Based CSG</a>.
</b> Journal of WSCG, 12(2):221-228, 2004. </p>
<p> This paper gives an introduction to image-based CSG rendering and describes
    the two techniques that are used in OpenCSG to accelerate rendering compared
    to older implementations: Visibility transfer using textures and occlusion
    queries for the SCS algorithm. </p>
</td>
</tr>
<tr>
<td valign="top" style="text-align: center;"><a href="http://www.opencsg.org/publications.html#freenix"><img src="img/opencsglogo.gif" alt="OpenCSG-Icon" /></a></td>
<td>
<p><b>F. Kirsch, J. Döllner:
      <a href="http://www.opencsg.org/publications.html#freenix">OpenCSG: A Library for Image-Based CSG Rendering</a>.
</b> Proceedings of the FREENIX / Open Source Track, 2005 USENIX Annual Technical Conference, 129-140, 2005. </p>
<p> This paper describes OpenCSG itself. It concentrates on the API, explaining
    internal implementation details only as shortly as possible. It also outlines
    possible non-obvious uses of OpenCSG. </p>
</td>
</tr>
<tr>
<td valign="top" style="text-align: center;"><a href="http://www.opencsg.org/publications.html#diss"><img src="img/diss.gif" alt="Dissertation-Icon" /></a></td>
<td>
<p><b>F. Kirsch:
      <a href="http://www.opencsg.org/publications.html#diss">Entwurf und Implementierung eines computergraphischen Systems zur Integration komplexer, echtzeitfähiger 3D-Renderingverfahren</a>.
</b>Published online, URN: <a href="http://opus.kobv.de/ubp/volltexte/2005/607/">urn:nbn:de:kobv:517-opus-6079</a>, 2005. </p>
<p> My doctoral dissertation (in german) describes an approach for integration
    and combination of several rendering techniques using a scene graph system. 
    As such, it contains a long chapter covering CSG rendering. </p>
</td>
</tr>
</tbody>
</table>

<center><a href="http://www.opencsg.org/img/grid.jpg"><img src="img/grid.gif" border="0" alt="CSG columns"></a></center>

<hr>

<h3> <a name="FAQ">FAQ</a> </h3>

<ol>
  <li>
    <p><b>Can I render a shape with
    different colors? The documentation says I must not change the primary
    color in the function of my class for primitives, since
    OpenCSG uses the color for internal purposes.</b> </p>
    <p> You can shade your shapes with whatever color you want.
      While your primitive objects for use in OpenCSG must not use
    the primary color, after calculating z-values with OpenCSG you are free
    to render the same geometry with primary colors. </p>
  </li>
  <li>
    <p><b>Can OpenCSG calculate the geometry of a CSG expression?</b> </p>
    <p> No, unfortunately this is not possible using image-based CSG algorithms
        (at least not in a trivial way). If you require this, have a look
        at other libraries such as the
        <a href="http://gts.sourceforge.net">GTS library</a>. </p>
  </li>
  <li>
    <p><b>What are the dependencies of the example program?</b> </p>
    <p> The OpenCSG example requires <a href="http://www.opengl.org/resources/libraries/glut.html">GLUT</a>. This library is likely pre-installed with your
        favorite linux installation. Visual Studio users can install
        <a href="http://www.xmission.com/~nate/glut.html">GLUT for Windows</a>.
        Dev-C++ users can install the <a href="http://mywebpage.netscape.com/PtrPck/glut.htm">precompiled GLUT for Mingw32</a>. </p>
  </li>
</ol>

<center><a href="http://www.opencsg.org/img/columns.jpg"><img src="img/columns.gif" border="0" alt="CSG columns"></a></center>

<hr>

<h3> <a name="license">License</a> </h3>

<p>
OpenCSG is copyrighted by Florian Kirsch and by the Hasso-Plattner-Institute
at the University of Potsdam (HPI), Germany.
</p>

<p>
You can license OpenCSG by terms of the <a href="http://www.gnu.org/copyleft/gpl.html">
GNU GPL, Version 2</a>. This means that you may release applications or libraries
that use (parts of) OpenCSG 
(a) only if you release the complete source code of your application or library
and (b) only if you release it under the GPL license.
</p>

<p>
If you do not want to release your source code unter terms of the GPL, 
you can't use and link against OpenCSG and ship the software by licensing
it unter GPL. In this case, e.g., if you want to use OpenCSG in a proprietary
application or library, you can always ask for a separate license and use 
it for development and production purposes.
</p>

<p>
According to the GPL, you are free to modify and redistribute OpenCSG
under terms of the GPL. We welcome contribution of your modifications to 
OpenCSG, however to let us integrate your modifications into OpenCSG, 
you must assign the copyright of the modifications to the HPI, 
Florian Kirsch. In other words, modifications from you that you would 
like to be integrated into OpenCSG should not hinder us to distribute 
OpenCSG under other, non-free licenses.
</p>

<p>
Note that OpenCSG comes with code that is not under copyright
of the HPI or Florian Kirsch. These are <a href="http://glew.sourceforge.net/">GLEW</a>
and <a href="http://sourceforge.net/project/showfiles.php?group_id=104004&amp;package_id=115053">
RenderTexture</a>. These libraries are licensed under the terms of
their respective authors. 
</p>

<center><a href="http://www.opencsg.org/img/grid.jpg"><img src="img/grid.gif" border="0" alt="CSG columns"></a></center>

<hr>

<center><p>
&copy; 2002-2010, Florian Kirsch, e-mail: <b>mail at opencsg dot org</b>, <br>
2002-2005 Hasso-Plattner-Institute Potsdam.<br>
Last change: 09.06.2010
</p></center>

</body>
</html>
